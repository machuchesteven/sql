# Single Rows Functions Available in SQL

This chapter looks at individual sql fnctions and how you should use them, individually and in combination with other functions

This chapter looks at single row functions.

## Basics on Functions in SQL

They have the following 3 characteristics:-

- They may accept incoming values or params (note: a few funcs take no param)
- They process incoming data, eg calculations or some other acts
- They return one single answer as a result

forexample, Here is a function called `INITCAP` taken by a SQL statement

```sql
SELECT FIRST_NAME, INITCAP(LAST_NAME) FROM SUBSCRIBERS;
-- the codes for the table are autogenerated by the python script
-- funcs.py
```

In this example, for each row, the init cap will return a value of the last name column with Initial Capital letter,

Functions can be called from any place, that an expression can be called.

- a SELECT statement's select list and WHERE clause
- an INSERT statement's list values
- an UPDATE statement's SET clause and WHERE clause
- a DELETE statement's WHERE clause
- and more

The major types of SQL functions include the following:-

- `Built-in Functions` - Those part of SQL language, available on every standard implementation
- `User-Defined Functions` - Created by User, Written with features going beyond capabilities of SQL using languages like PL/SQL

We will only deal with built-in functions, for the exam

Built in functions are many and great, they fall into several categories, most common categories are:-

1. Character functions - Are used to manipulate text, like analyze length(LENGTH), pad it with extra characters(RPAD, LPAD), trim off unwanted characters(RTRIM, LTRIM, TRIM), locate a given string (INSTR), extract a smaller string from a larger string(SUBSTR), and replace text within a string (REPLACE), also for strings that sounds the same (SOUNDEX)
2. Number functions - can perform mathematical analysis eg, for sine(SIN, ASIN, SINH), cosine(COS, ACOS, COSH), and tangent(TAN, ATAN, ATAN2. , TANH), determine absolute values(ABS), and deterime whether the number is negative or positive(SIGN), round of values(ROUND), abbreviate numbers(TRUNC), they can be incorporated with some expressions, and more
3. Date functions - You can obtain current date and time (SYSDATE and SYSTIMESTAMP), "round" date to a vary degree of detail(ROUND) and otherwise abbreviate them(TRUNC). Also, calculate diff btn two or more dates, Simple arithmetic operators will help determine the difference between two dates in term of days, meaning if you substract, the resulting answer will be the difference in term of days, so what if you need in months(MONTHS_BETWEEN), ADD_MONTHS - for both -ve and +ve month values, also other funcs like deterimining the weekday from a date, later in next chapter
4. Other functions - eg USER, takes no param and returns the value showing the name of the user account, there are more functions too

## Use NUMBER, DATE, and ANALYTICAL functions

Here we look at functions like PECENTILE_CONT, STDDEV, LAG, LEAD functions in SELECT statement

### The DUAL table

Is a table existing in all oracle dbs, it contains one column, DUMMY with a data type of varchar2(1), and one row of value DUMMY `X`.

The purpose of the DUAL is to have something to run a select statement against when you don't want to retrieve any data in particular, but simply want to run a select statement to get some other task accomplished eg obtaining the output of a function.

Hence selecting any function from dual, gives the result for those functions, eg to get the system date

```sql
SELECT SYSDATE FROM DUAL;
```

### CHARACTER functions

Looks in details for more used character functions, some have numeric params and others even numeric outputs liek INSTR, but the overall aim is to perform some data manipulation on text

#### UPPER and LOWER

They are very useful when doing text search and not sure whether the data is in uppercase or lowercase, hence missing any chance of missing mixed-case text
syntax:-

```sql
UPPER(s1) -- transform S1 into uppercase letters
LOWER(s1) -- transform S1 into lowercase letters
SELECT UPPER(company_name), LOWER(company_name) FROM GOOD_PROJS;
```

make sure if is in a text search, use transformation characters in both sides of the where condition, use the function to standardize the case of both values being compared.

#### INITCAP

Transforms the characters given into a mixed-case string, starting with an upper case character, then follower by a series of lower case characters

`NOTE`:- Single quote escape character activates enables single quote characters to be displayed as single quotes,

```sql
SELECT 'O''Hearn' FROM DUAL;
SELECT 'O'Hearn' FROM DUAL; -- This does not work

```

Using double single quote character, tells oracle to use the single quote as a character,
not a string delimiter

Also, initcap for Words like `Hern 'O'Brien`, will work well with initcap but the string `McDonald's` will turn into `Mcdonald'S` - the S will be upper cased

#### CONCAT OR ||

Syntax

```sql
CONCAT(s1, s2) -- concats the strings `s1` and `s2` into a new string
s1 || s2 -- does the same as above
```

Concat only takes 2 params, double pipe operator can be repeated multiple times, The result is a single string

#### LPAD, and RPAD

syntax

```sql
LPAD(s1, n,s2) -- S1-string, required, n - number -required, s2 - string -optional, default a single blank space
RPAD(s1, n,s2) --
```

This pads the left (LPAD) or the right (RPAD) of string s1 with with character s2 so that the resulting string is n characters long
Many functions are useful in and of themselves, but becmes more useful when combined with others.

Consider the following example

```sql
select rpad(content_title, 30, '.') || lpad(' '|| page_number, 30, '.') from book_contents;
```

#### LTRIM and RTRIM

syntax

```sql
LTRIM(s1, s2) -- s1,required, s2 optional(blanks to an single blank space)
RTRIM(s1, s2)
```

Removes the occurences of characters of s2 from the left LTRIM or right RTRIM of the s1 string

```sql
SELECT RTRIM('HELO -----', '-') FROM DUAL;
```

#### TRIM

Syntax:-

```sql
TRIM(trim_info trim_char from trim_source)
```

Consider the definition of terms:-

- trim_info is one of these keywords: `LEADING`, `TRAILING`, `BOTH`, if ommitted defaults to `BOTH`.
- trim_char: single character to be trimmed - if ommitted assumes to be blank
- trim_source: source string to be trimmed, if ommitted assumes to be NULL

Works in the same way as LTRIM and RTRIM but with slightly different syntax.

#### LENGTH

syntax:-

```sql
LENGTH(s) -- returns the length of the given string
```

#### INSTR

looks for occurences of **s2** in the given string **s1**, starting with **n**th occurrence, start looking from position **pos**
syntax:-

```sql
INSTR(s1, s2, pos,n); -- s1-req, s2-req, pos-opt[default=1, if -ve starts from the end and looks backwards], n-optional[default=1]
```

#### SUBSTR

Extracts and returns a susbtring from **s**, starting from the **pos**, and extracts a length **len**.

```sql
SUBSTR(s, pos, len); -- s- req, pos-req, len-optional[default=to the end of the string]
```

#### SOUNDEX

Translates a source string into its SOUNDEX code, and returns a character string

syntax `SOUNDEX(s)`
Similar to sounding words, tend to generate same SOUNDEX patter

Procedures of SOUNDEX

1. Leave the first letter unchanged
2. THen perform translation for the coming letters till 3 digits are created
3. Other letters beyond that are ignored

SOUNDEX translation table

- `B, F, P, V` - 1
- `C,G, J, K, Q, S, X, Z` - 2
- `D, T` - 3
- `L` - 4
- `M, N` - 5
- `R` - 6
- Others are ignored

soundex of two words can be used comparatively

```sql
select * from table where soundex(column) = soundex(value); -- using soundex in one side is useless
```

SOUNDEX is not perfect but rather useful, and is designed to work with American Language and pronounciation

### NUMERIC FUNCTIONS

The intent of these is to perform numeric analysis and tasks associated with numeric manipulation and data processing

#### CEIL - `CEIL(n)`

n - is required and is any numeric data type,

returns the smallest integer that is greater than or equal to n, eg CEIL(1.3) => 2, ceil(1.0) => 1

#### FLOOR - `FLOOR(n)`

n is any numeric data type,

returns the largest integer that is less than or equal to n eg FLOOR(1.0) => 1, flor(1.9) => 1, flor(2.0) => 2

#### ROUND - `ROUND(n, i)`

n - required and is any numeric data type, i - opt[default = 0], precision of rounding

rounded to the nearest whole number

if n is:-

1. Positive - to the nth decimal point
2. Negative - to the nth position before the decimal point, and ignore the decimal point
3. o or ommitted - to the nearest whole number

#### TRUNC - `TRUNC(n, i)`

n - any number and can include decimal, i - opt[default = 0]

process: Rounds towards zero, in other words, it truncates the number

#### REMAINDER - `REMAINDER(n1, n2)`

n1, n2 - numbers and both are required

identifies the multiple of n2 that is near to n1 and returns the diff between them, it can return both -ve and +ve based on how close that multiple is, eg for 9 and 3, 0, for 9 and 10, 1, for 9 and 11, -1 since that is the closest

#### MOD - `MOD(n1, n2)`

n1, n2 - both are numbers and required

process: performs the same task but uses floor instead of round in its calculations, meaning `MOD(n1, n2)` = `n1 % n2`

### DATE Functions

Looks at functions that works primarily with date data types

#### SYSDATE - `SYSDATE`

takes no paramter, and returns the current date and time based on the OS on which Oracle runs in, the format returned by the function can be altered by changing the `NLS_DATE_FORMAT` parameter for the session

```sql
SELECT SYSDATE FROM DUAL;
```

#### ROUND - `ROUND(d,i)`

d is the date and i is the format model(optional) specified, round off d to the nearest date value based on i, on other words, to the nearest day, nearest hour, and nearest month, nearest year and so on.

if `i` is ommitted will result to the value rounded to the nearest whole day. Values are biased to rounding up, eg 12 noon results to the next day

```sql
SELECT SYSDATE TODAY, ROUND(SYSDATE, 'MM') ROUNDED_MONTH, ROUND(SYSDATE, 'RR') ROUNDED_YEAR, ROUND(SYSDATE) ROUND_DAY FROM DUAL;
-- The value of min, hrs and seconds are s
SELECT TO_CHAR(ROUND(SYSDATE), 'DD-MM-RR HH:MI:SS') ROUNDED_DAY FROM DUAL;
```

Round always returns the whole values for both date and time, whether they are displayed or not.

#### TRUNC - `TRUNC(d, i)`

Performs the same function as `ROUND` except that it always rounds down, d is the date, i is the format model(optional)

```sql
SELECT TRUNC(sysdate, 'mi') AS TRUNC_MIN FROM dual;
```

#### NEXT_DAY - `NEXT_DAY(d,c)`

Returns the next occurence of day `c`(text reference of the day of the week) of the week from the date given by `d`.

```sql
SELECT NEXT_DAY(SYSDATE, 'Saturday') FROM DUAL;
```

#### LAST_DAY - `LAST_DAY(d)`

Returns the last day of the month in which `d` falls in

```sql
SELECT LAST_DAY(SYSDATE) FROM DUAL;
```

#### ADD_MONTHS -`ADD_MONTHS(d, i)`

returns the date after adding the number of months `i` to the date `d`. There is no SUBSTRACT_MONTHS, instead put `i` negative to subtract the number of months

```sql
SELECT ADD_MONTHS(SYSDATE, 3), ADD_MONTHS(SYSDATE, -3) FROM DUAL;
```

#### MONTHS_BETWEEN - `MONTHS_BETWEEN(d1, d2)`

returns the number of months between the two dates, d1 - d2, if the value is negative means n2 > n1. The value does not autmatically round off, it will show only real values

```sql
SELECT MONTHS_BETWEEN('07-feb-23', '07-may-23'), MONTHS_BETWEEN('07-feb-24', '07-may-23') FROM DUAL;
```

#### NUMTOYMINTERVAL - `NUMTOYMINTERVAL(n, interval_unit)`

`NumberToYearToMonthInterval` converts the number value to a year to month interval, interval_unit must be one of the following `YEAR` and `MONTH` values, this means n is of those specified interval.

converts n to 'yy-mm' month interval, meaning an interval in years and months, takes n which might be +ve or -ve, or decimal

```sql
SELECT NUMTOYMINTERVAL(12, 'year') FROM_12_YEARS FROM DUAL;
```

#### NUMTODSINTERVAL - `NUMTODSINTERVAL(n, interval_unit)`

converts the n value to Day to Seconds interval, the interval unit can be `Day, Hour, Minutes, Seconds`

```sql
SELECT NUMTODSINTERVAL(2400, 'HOUR') FROM DUAL;
```

### DATES and NUMBER Constants

To perform arithmetic with days, we use literals, number 1 presents 1 day,
1/24 represents on hour, 12/1440 represents 12 minutes and so on, hence using literals works fine with date values

## Analytical Functions

Types of functions in the exam

- Scalar functions - returns one answer for one row
- Aggregate functions - returns one answer for multiple rows
- Analytical functions - falls between the two functions

Analytic functions are tha last functions performed in the query prior to the ORDER BY clause

Analytic functions are forbidden in the `WHERE`, `GROUP BY`, and `HAVING` clauses

mostly used analytic functions are:-

- `OVER` -
- `PARTITION BY` -
- `GROUP BY` -

to see how they are used, consider the ships table with the following columns

| ship_id | room | window | sqr_ft |
| ------- | ---- | ------ | ------ |
| 1       | 102  | Ocean  | 533    |
| 2       | 103  | Ocean  | 160    |
| 3       | 104  | Ocean  | 533    |
| 4       | 105  | None   | 586    |
| 5       | 106  | Ocean  | 205    |
| 6       | 107  | None   | 1524   |

we can use sum as an `aggregate` to obtain the total sum of sqr_ft

Also, we can use sum as an `analytic` function to obtain the cumulative sum as below

### `ORDER BY` AND `OVER`

```sql

SELECT SUM(SQR_FT) FROM SHIPS;

SELECT ID, WINDOW, SUM(SQR_FT) OVER (ORDER BY SQR_FT) "CUMULATIVE SQR_FT" FROM SHIPS ORDER BY ID;

SELECT ID, WINDOW, SUM(SQR_FT) OVER (ORDER BY ID) "CUMULATIVE SQR_FT" FROM SHIPS;
```

The function displays the values of SUM that builds within its own window.

### `PARTITION BY`

Partition will builds the means of subsetting windows based on certain criteria

```sql
SELECT ID, WINDOW, SUM(SQR_FT) OVER (PARTITION BY WINDOW ORDER BY ID) "CUMULATIVE SQR_FT" FROM SHIPS;

SELECT ID, WINDOW, SQR_FT, SUM(SQR_FT) OVER (PARTITION BY WINDOW ORDER BY ID) "CUMULATIVE SQR_FT", SUM(SQR_FT) OVER (PARTITION BY WINDOW ORDER BY ID ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) "SUBSET_CUMULATIVE" FROM SHIPS ORDER BY ID;

```

For sliding windows functions, the following are some of the available options after `ROWS BETWEEN`

- `rows between Unbounded Preceding and Current Row` - ALL ROWS before current row and current row
- `rows between N Preceding and Current Row` - current rows and N rows before current row
- `rows between current and current row` - only current rows included
- `rows between N Preceding and M Following` - N rows before current row and M rows after current row
- `rows between Current and M Following` - M rows after current row and the current row
- `rows between Current Row and Unbounded Following` - M rows after current row and all rows after current row

### LAG, LEAD

LAG for a given row in a window, it shows the value of the preceding row of that column

LEAD for a given row in a window, it shows the value of the following row of that column

```sql
LAG
  { ( value_expr [, offset [, default]]) [ { RESPECT | IGNORE } NULLS ]
  | ( value_expr [ { RESPECT | IGNORE } NULLS ] [, offset [, default]] )
  }
  OVER ([ query_partition_clause ] order_by_clause)
```

The syntax above works for all

```sql
SELECT ID, LAG(ID) OVER (ORDER BY ID), LEAD(ID) OVER (ORDER BY ID) ,LAG(ID) OVER (PARTITION BY WINDOW ORDER BY ID), LEAD(ID) OVER ( PARTITION BY WINDOW ORDER BY ID) FROM SHIPS;
```

Each analytic function defines its own window

### STDDEV

deviation of numbers from the mean or the square root of the variance.

VARIANCE AND STDDEV functions can be used as AGGREGATE Functions and Analytics Functions

consider below

```sql

select id, stddev(id) over (order by id) from ships;
select stddev(id), variance(id), avg(id), median(id) from ships;
select stddev(sqr_ft), variance(sqr_ft), avg(sqr_ft), median(sqr_ft) from ships;
```

### PERCENTILE_CONT - `PERCENTILE_CONT(ratio)`

`WITHIN GROUP(ORDER BY COLUMN` - COMBINES THE GROUP VALUE INTO A REPORT OBJECT
Takes as input the percentile you specify and returns the value based on the equivalent percentage ypur specified based on the window, that is equal to that percentage by using linear extrapolation

Forexample in our ships cabin, lets show the square footage for each cabin but for the cabns with the same type of window consider the largest footage, calculates 60% of that square footage, and display that amount

```sql
select window, room, sqr_ft, percentile_cont(0.6) within group (order by sqr_ft) over (partition by window) "PCT" from ships order by sqr_ft;
```

the within group order by over partition by window, first create those two partitions, the calculates the perctile over that partition

meaning the number that would exist at the 60th percent position in the partition

The fucntion does the following

- takes the CEIL for the calculated row RN position
- takes the FLOOR for the calculated row RN position

VALUE = `(CEIL- RN) * (VALUE AT THE FLOOR) + (FLOOR- RN) * (VALUE AT THE CEIL)`

## NESTED FUNCTIONS

When a one function is nested that its result is used as a function parameter, the nested function executes first. The innermost function executes first for multiple level nesting, when you include non-scalar functions, the nested functions starts to get complicated.

### NESTED FUNCTIONS AND PATTENS

consider getting the result from an addres column where street names are mapped between two comma values

the INSTR will help us get the position of the comma in that particular column, and extract the state using the following examples:-

```sql

SELECT 'Mikocheni, Dar es Salaam', INSTR('Mikocheni, Dar es Salaam', ', ') AS "COMMA", SUBSTR('Mikocheni, Dar es Salaam', INSTR('Mikocheni, Dar es Salaam', ',')) AS "State" from dual;

SELECT 'Mikocheni, Dar es Salaam', INSTR('Mikocheni, Dar es Salaam', ', ') AS "COMMA", SUBSTR('Mikocheni, Dar es Salaam', INSTR('Mikocheni, Dar es Salaam', ',')+2) AS "State" from dual;
```

## OTHER

### LEAST AND GREATEST

### RANK and DENSE_RANK

### FIRST and LAST
